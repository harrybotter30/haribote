Next: [harib00d](harib00d.md), Previous: [harib00b](harib00b.md), Up: [Chapter3](chapter3.md)

----

# Chapter3

## harib00b

### 課題

18 セクタまで読み込む。

### 学習

- セクタ番号を進めながら Disk BIOS 呼び出しで読み込む。
- 第 2 セクタから第 18 セクタまでの 17 セクタ分。
- 18 セクタまでなのは 1.44MB フロッピーでは 1 トラックあたり 18 セクタのため。

#### opcode

途中に

```Assembly
addw $0x0020, %ax
```

という行が出てくるが、リスティングファイルを確認したところ、```83 C0 20``` という命令にアセンブルされていた。

```Assembly
add ax, imm16
```

の ```05 20 00``` が生成されるものと思いきや、

```Assembly
add reg16, imm8
```
の ```100000sw``` ```mod 000 r/m``` ```imm8``` ということらしい。

オペコード | 意味
---------- | ----
w   | 0: 8 ビット操作、1: 16 ビット操作
s   | w == 0 のときは無視、w == 1 のときはオペランドサイズを指定

s  | 意味
-- | ----
0 | イミディエイトオペランドは 16 ビット
1 | イミディエイトオペランドは下位 8 ビットを符号拡張して使用する

オペランド | 意味
---------- | ----
mod | 上位 2 ビットで、メモリとレジスタのアドレッシングを区別する
000 | 中位 3 ビットで、この場合は使用しない
r/m | 下位 3 ビットで、mod == 11 の場合はレジスタを表す

mod | 意味
--- | ----
00 | r/m は絶対アドレスでディスプレイスメントなし
01 | r/m は絶対アドレスでその後に 1 バイトのディスプレイスメントが後続
10 | r/m は絶対アドレスでその後に 2 バイトのディスプレイスメントが後続
11 | r/m はレジスタで前述の w に応じてサイズが決まる

r/m（mod == 11 の場合） | 意味
----------------------- | ----
000 | w == 0: %al, w == 1: %ax
001 | w == 0: %cl, w == 1: %cx
010 | w == 0: %dl, w == 1: %dx
011 | w == 0: %bl, w == 1: %bx
100 | w == 0: %ah, w == 1: %sp
101 | w == 0: %ch, w == 1: %bp
110 | w == 0: %dh, w == 1: %si
111 | w == 0: %bh, w == 1: %di

今回の場合 ```83 C0 20``` なので、

- w == 1 から 16 ビット操作
- s == 1 からイミディエイトオペランドは下位 8 ビットのみ指定で符号拡張する
- mod == 11 から対象はレジスタ
- r/m == 000（かつ w == 1）から対象は %ax
- imm8 == 0x20 を符号拡張して使用

となり、

```Assembly
addw $0x0020, %ax
```

の意味になることが確認できた。

#### 参考

- [80x86 Instructions by Mnemonic](http://www.c-jump.com/CIS77/reference/Instructions_by_Mnemonic.html)

### 成果

- [ipl.S](/ipl.S)
    - 第 2 セクタから第 18 セクタまでの 17 セクタ分読み込む

----

Next: [harib00d](harib00d.md), Previous: [harib00b](harib00b.md), Up: [Chapter3](chapter3.md)
